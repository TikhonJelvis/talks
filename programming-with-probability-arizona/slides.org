#+Title: Programming /with/ Probability
#+Author: Tikhon Jelvis
#+Email: tikhon@jelv.is
#+REVEAL_HEAD_PREAMBLE: <meta name="description" content="Probability distributions form a monad. I'll talk about how we can use this monad in different ways to work with probability distributions in our code.">

#+REVEAL_TITLE_SLIDE_BACKGROUND: #052d69
#+REVEAL_TITLE_SLIDE_BACKGROUND_TRANSITION: none
#+OPTIONS: reveal_title_slide:"<h1 class='title'>%t</h1> <h2 class='subtitle'>%s</h2> <h3 class='author'>%a</h3>"

# Options I change before uploading to jelv.is:
#
# - set controls to true
# - change reveal_root
#+REVEAL_INIT_OPTIONS: controls:false, center:true, progress:false, transition:"none", autoAnimate: false
#+REVEAL_ROOT: ../reveal.js-3.8.0/

#+OPTIONS: num:nil toc:nil timestamp:nil email:t

#+REVEAL_MARGIN: 0.1
#+REVEAL_MIN_SCALE: 0.5
#+REVEAL_MAX_SCALE: 2.5
#+REVEAL_TRANS: slide
#+REVEAL_THEME: tikhon
#+REVEAL_HLEVEL: 2

#+REVEAL_POSTAMBLE: <p> Created by Tikhon Jelvis. </p>
#+REVEAL_PLUGINS: (highlight markdown notes)

* Math as design language  

* 
  Uncertainty is hard

* 
  Uncertainty + business logic:

  even harder

* 
  1. Supply chain optimization
  2. Software design
  3. The probability monad
  4. Markov processes

* Supply Chain Optimization
   :PROPERTIES:
   :reveal_background: #052d69
   :reveal_background_trans: none
   :reveal_extra_attr: class="section-slide"
   :END:
   
** Target
  - 1978 stores
  - 62 distribution centers

** Target
  [[./img/dc-map.png]]

** Demand Uncertainty
  [[file:img/item-demand.png]]

** How do we...
  - *model* supply chain behavior?
  - make *decisions*?

* Software Design
   :PROPERTIES:
   :reveal_background: #052d69
   :reveal_background_trans: none
   :reveal_extra_attr: class="section-slide"
   :END:

** How do we manage complexity in our code?

** 
   #+ATTR_HTML: :width 800px :class no-background
   [[file:img/code-design.svg]]

** 
   #+ATTR_HTML: :width 800px :class no-background
   [[./img/code-design-concepts.svg]]

** Math + Functional Programming

** 

   \begin{equation}
   f: \mathbb{R} \to \mathbb{R} \\
   f(x) = 1 + 2x + 2x^2
   \end{equation}

   #+begin_src haskell
   f :: Double → Double
   f x = 1 + (2 * x) + (2 * x ^ 2)
   #+end_src

   Sets become *types*

** 

   \begin{equation}
   f: \mathbb{R^2} \to \mathbb{R} \\
   f(x, y) = 1 + 2xy + 2x^2y
   \end{equation}

   #+begin_src haskell
     f :: Double → Double → Double
     f x y = 1 + (2 * x * y) + (2 * x ^ 2 * y)
   #+end_src

   #+begin_src haskell
     g :: Double → Double
     g x = f x (x + 1) + f (x + 1) x
   #+end_src

** 

  \begin{equation}
  F: \textbf{Set} → \textbf{Set} \\
  \end{equation}

  \begin{equation}
  \eta: 1_{\textbf{Set}} \to F \\
  \eta_X: X \to F(X)
  \end{equation}
  
  #+begin_src haskell
    point :: ∀a. a → F a
  #+end_src

** 
  #+being_src haskell
    point :: ∀f. ∀a. Pointed f ⇒ a → f a
  #+end_src


* Probability Distributions
   :PROPERTIES:
   :reveal_background: #052d69
   :reveal_background_trans: none
   :reveal_extra_attr: class="section-slide"
   :END:
   
** 
   #+ATTR_HTML: :width 600px
   [[./img/poisson.svg]]

** 
  \begin{equation}
  X \in \mathbb{Z} \\
  P(X) \\
  \end{equation}

  #+begin_src haskell
    data Dist a = ...

    example :: Dist Integer
  #+end_src

** 
  \begin{equation}
  X \in \mathbb{Z} \\
  Y \in \{0, 1\} \\
  P(X|Y)
  \end{equation}
  
  #+begin_src haskell
    example :: Bool → Dist Integer
  #+end_src
  
** Functor
  [[file:img/functor-diagram.jpg]]

  #+begin_src haskell
    fmap :: Functor f ⇒ (a → b) → (f a → f b)
  #+end_src

  #+begin_src haskell
    fmap :: (a → b) → (Dist a → Dist b)
  #+end_src

** Monad
  \begin{align}
  & D: \textbf{X} → \textbf{X} \\
  & \eta: 1_{\textbf{X}} → D \\
  & \mu: D \circ D \to D
  \end{align}

  #+begin_src haskell
    data Dist a

    pure :: a → Dist a

    join :: Dist (Dist a) → Dist a 
  #+end_src

** Monad
  #+begin_src haskell
  bind :: Dist a → (a → Dist b) → Dist b
  bind dist f = join (fmap f dist)
  #+end_src

  \begin{align}
  & P(X|Y) \\
  & P(Y) \\
  & P(X)
  \end{align}

** 
   #+BEGIN_SRC haskell
   die ∷ Dist Int
   die = uniformD [1..6]
   #+END_SRC

   #+BEGIN_SRC haskell
   diceGame ∷ Dist Int
   diceGame = do
     n  ← die
     xs ← replicate n die
     pure (sum xs)
   #+END_SRC

** Different Interpretations 

   1. Each ← /samples/ the distributions
   2. Each ← calculates /all combinations/
   3. More sophisticated algorithms

* Uncertainty over Time

** Markov Processes

** Simulations

** Markov Decision Processes
