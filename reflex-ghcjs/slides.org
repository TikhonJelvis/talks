#+Title: Reflex FRP
#+Author: Tikhon Jelvis
#+Email: tikhon@jelv.is

#+OPTIONS: reveal_center:t reveal_progress:nil reveal_history:t reveal_control:nil
#+OPTIONS: reveal_mathjax:t reveal_rolling_links:t reveal_keyboard:t reveal_overview:t num:nil
#+OPTIONS: reveal_width:1200 reveal_height:800 reveal_rolling_links:nil
#+OPTIONS: toc:nil timestamp:nil email:t
#+REVEAL_MARGIN: 0.1
#+REVEAL_MIN_SCALE: 0.5
#+REVEAL_MAX_SCALE: 2.5
#+REVEAL_TRANS: slide
#+REVEAL_THEME: tikhon
#+REVEAL_HLEVEL: 2
#+REVEAL_HEAD_PREAMBLE: <meta name="description" content="Overview of functional reactive programming as a beautiful abstraction.">
#+REVEAL_POSTAMBLE: <p> Created by Tikhon Jelvis. </p>
#+REVEAL_PLUGINS: (highlight markdown notes)

* Internal Tools

* Internal Tools
  [[./img/haskell-ekg.png]]

* Internal Tools
  - dashboards, monitoring
  - admin consoles
  - simulations, visualizations
  - code analysis, benchmarking

* What do we care about?

* Easy to write.

* Easy to maintain.

* Performance? Size?
  Less important.

* Code reuse /is crucial/.

* No Code Reuse
  [[./img/no-share.png]]

* Reuse Types
  [[./img/share-types.png]]

* Reuse Types & API
  [[./img/share-interface.png]]

* GHCJS
  - Haskell ⇒ JavaScript
  - supports most GHC extensions
  [[./img/haskell-in-browser.png]]

* Reflex
  - FRP framework
  - virtual DOM
  - [[https://github.com/imalsogreg/servant-reflex][servant-reflex]] (work in progress?)

* Functional Reactive Programming

* Time-Varying Values

* Time-Varying Values
  - time is *explicit*
  - changing values are *first-class citizens*
  - composable
  - declarative

* Behaviors and Events
  - *Behavior*: continuously changing value
    - mouse position: =Behavior (Int, Int)=
  - *Events*: values /at discrete times/
    - mouse click: =Event (Int, Int)=

* 〚Behavior a〛 = Time → a

* 〚Event a〛 = Stream (Time, a)
  
* Dynamic
  Event ⇒ Event + Behavior

* Input ⇒ Combinators ⇒ Output

* Input
  - user input widgets

  #+BEGIN_SRC haskell
  text ← textInput inputConfig

  text ^. value :: Dynamic t Text
  #+END_SRC

  - timers

  #+BEGIN_SRC haskell
  tick :: NominalDiffTime 
        → UTCTime → m (Event t ())
  #+END_SRC

* Combinators

  #+BEGIN_SRC haskell
  gate :: B t Bool → E t a → E t a
  hold :: a → E t a → m (B t a)
  tag  :: B t b → E t a → E t b

  -- typeclasses:
  fmap  :: (a → b) → E t a → E t b
  (<*>) :: B (a → b) → B a → B b
  #+END_SRC

* Output

  #+BEGIN_SRC haskell
  dynText :: MonadWidget t m ⇒ 
             Dynamic t Text → m ()

  dyn :: MonadWidget t m ⇒
         Dynamci t (m a) → m (Event t a)
  #+END_SRC

* Example
  
  [ screenshot ]

* 
    1. user types query
    2. call HTTP API
    3. parse JSON response
    4. render results

* Types
  #+BEGIN_SRC javascript
  #+END_SRC

* Types
  #+BEGIN_SRC haskell
  #+END_SRC

* API
  - input event determines *when* request fires
  #+BEGIN_SRC haskell
  getAndDecode = ...
  #+END_SRC

* Input
  - fire whenever input updates

* Render Results
  - dyn widget and so on

* Pros
  - expressive
  - short (< 40 lines of code!)
  - extensible
  - maintainable
  - *in Haskell!*

* Cons
  - documentation
  - CSS and HTML
  - intermediate Haskell experience
    - bad type errors: turn off MMR
  - GHCJS infrastructure
    - [[https://github.com/reflex-frp/reflex-platform][reflex-platform]]: turnkey solution using Nix

* Vs Elm
  - cons:
    - *not Haskell!*
    - 2x code, more boilerplate
    - Elm architecture: verbose and non-modular

  - pros:
    - good documentation
    - easy for non-Haskellers and beginners

* Questions?

* Picture Credits
  - Haskell EKG screenshot by [[http://maxgabriel.github.io/ekg-yesod/][Max Tegher]]
